# 第二章 复杂度分析
## 2.1 算法效率评估
- **算法设计目标**
  - **找到问题解法：** 算法在规定的输入范围内可靠地求的问题的正确解
  - **寻找最优解法：** 同一问题存在多种解法，找到尽可能高效的解法
- **算法效率：**
  - **时间效率：** 算法运行速度的快慢
  - **空间效率：** 算法占用空间的大小
- **2.1.1 实际测试**
  - **测试环境的干扰：** 不同硬件配置，会导致同一算法在不同机器上效率差异很大
  - **完整测试耗费资源：** 输入数据量的变化，会导致同一算法在不同输入数据量下效率差异很大
- **2.1.2 理论估算**
  - **复杂度分析：** 描述了随着输入数据大小的增加，算法执行所需的时间和空间的增长趋势

## 2.2 迭代和递归
- **2.2.1 迭代：** 一种重复之行某个任务的控制结构
  - **for循环：** 适合在预先知道迭代次数时使用
  - **while循环：** 自由度更高，可以自由设计条件变量的初始化和更新步骤
  - **嵌套循环**
**- 2.2.2 递归：** 一种算法策略，通过函数调用自身来解决问题
  - **递：** 程序不断深入地调用自身，通常传入更小或简化的参数来直到达到终止条件
  - **归：** 触发终止条件后，从最深层逐层的函数开始逐层返回，汇聚每一层的结果
  - **三个要素：**
    - **终止条件：** 决定什么时候由递转归
    - **递归调用：** 对应递，函数调用自身，通常输入更小或简化的参数
    - **返回结果：** 对应归，将当前递归层级的结果返回至上一层
  - **调用栈：** 递归函数每次调用自身，系统会为新开启的函数分配内存（栈帧），存储局部变量、调用地址等信息
    - 递归比迭代更耗费内存空间
    - 递归比迭代的时间效率更低
  - **尾递归：** 递归调用是函数返回前的最后一个操作，则函数可以被编译器优化，使其迭代效率相当。
  - **递归树：** 在递归函数内调用两个递归函数，以此不断递归下去，最终形成递归树

## 2.3 时间复杂度
  - **2.3.1 统计时间增长趋势：** 时间复杂度分析统计的不是算法的运行时间，而是算法运行时间随着数据量变大时的增长趋势。
  - **2.3.2 函数渐进上界：** 计算T(n)的渐近上界就是寻找一个函数法f(n)，使得当n趋近于无穷大时，f(n)是T(n)处于相同增长级别，仅相差一个常数项c的倍数。
  - **2.3.3 推算方法**
    - **第一步 统计操作数量**
      - 忽略T(n)中的常数项
      - 省略所有系数，如2n、5n+1都可简化为n次
      - 循环嵌套时使用乘法，如两个嵌套循环，外层循环次数为n，内层循环次数为n，则总操作次数为n^2
    - **第二步 判断渐进上界：** 时间复杂度有T(n)中的最高阶的项来决定，当n趋近于无穷大时，最高阶的项发挥主导作用，其他项可以忽略。
  - **2.3.4 常见类型：** O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)
    - **常数阶O(1)：** 常数阶的操作数量与输入数据大小n无关，即不随着n的变化而变化
    - **线性阶O(n)：** 线性阶的操作数量相对于输入数据大小n以线性级别增长
    - **平方阶O(n^2)：** 平方阶的操作数量随着输入数据n以平方级别增长，通常出现在循环嵌套中
    - **指数阶：O(2^n)：** 指数阶相当于细胞分裂，由一分为二，二分为四，四分为八依次下去，通常出现在递归函数中
    - **对数阶O(logn)：** 对数阶反映了一分为多、化繁为简的思想，通常出现在基于分治策略的算法中，一分为m的时间复杂度为O(logm为底的n次方)，通过换底公式可以省略底数m，将对数阶记为O(logn)
    - **线性对数阶O(nlogn)：** 常出现于嵌套循环中，两层循环分别为O(n)和O(logn)，总时间复杂度为O(nlogn)，如快速排序、归并排序、堆排序等
    - **阶乘阶O(n!)：** 通常出现在全排列问题中，使用递归实现，如第一层分裂出n个，第二层分裂出n-1个，依次类推，直至第n层停止分裂
