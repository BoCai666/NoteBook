# 引用

## 1.简介

**本质：** 在c++内部实现一个指针常量

**作用：** 给变量起别名，两者操作的是同一内存空间。

**语法：** `数据类型 &别名 = 原名`

```c++
int a = 10; // 相对开了一片空间，a指向该空间，空间内存的值为10
int& b = a; // 将a指向的空间地址赋值给b
b = 100; // 修改空间中存的值
cout << a << endl; // 输出100
cout << b << endl; // 输出100

// 本质
int a = 10;
int& ref = a; // 编译器会自动转换为 int* const ref = &a;
ref = 20; // 内部发现ref是引用，编译器会自动转换为*ref = 20;
```



## 2.常量引用

**作用：** 常量引用主要用来修饰形参，防止误操作

在函数参数列表中，可以加const修饰形参，防止形参改变实参

```c++
int& ref = 10; // 错误：引用必须引一块合法的内存空间
const int& ref = 10; // 正确：编译器自动转换为int temp = 10; const int& ref = temp;
ref = 20; // 错误：加了const后变为只读，不可修改

// 在一些函数中，想要某些形参是只读，不可写时则可加const修饰
void Debug(const int& a) 
{
	a = 100; // 错误：a的值不可修改    
}
```



## 3.注意事项

- 引用必须初始化
- 引用在初始化后，不会再改变该引用变量所指向的内存空间（只是赋值操作）

```C++
int& a; // 错误：必须初始化
int a = 10;
int b = 100;

int& c = a; // a与c指向同一内存空间
c = b; // 相对于赋值操作 将b存的100赋值给了c，不会将b指向的内存地址赋值给c

// abc三者的存的值相同
// c与a的内存地址相同，但与b内存地址不同，
cout << &a << endl;
cout << &b << endl;
cout << &c << endl;
```



## 4.引用做函数参数

**作用：** 函数传参是，可以用引用的技术让形参修饰实参

**优点：** 可以简化指针修改实参，与地址传递的效果一样，但引用的语法更清楚简单

```c++
// 1.值传递
void Swap(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 2.地址传递
void Swap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 3.引用传递
void Swap(int& a, int& b)
{
    int temp = a;
    a = b;
    b = temp;
}
```



## 5.引用做函数返回值

- 函数返回值为引用时，函数调用可以作为左值
- 不要返回局部变量引用，局部变量在方法调用完就释放了，以引用返回值的形式操作是非法的

```c++
int& Test() 
{
    static int a = 10;
    return a;
}
int& b = Test();
Test() = 1000;
cout << b << endl; // 输出1000
```

