# 对象

## 1.浅拷贝与深拷贝

- **浅拷贝**

  将对象的属性的值进行拷贝，当对象中某些属性存放在堆区时，浅拷贝是直接将该属性指向的空间地址进行拷贝，可能造成堆区的内存重复释放

- **深拷贝**

  将对象的属性的值进行拷贝，当对象中某些属性存放在堆区时，深拷贝是将该属性指向的空间中的值，放到一个重新申请的空间中

```C++
class Person
{
public:
    int a;
    int* b;
    
    Person(const Person p)
    {
        a = p.a;
        b = p.b; // 浅拷贝 直接拷贝的地址，两者指向的空间还是一样的
        b = new int(*p.b) // 深拷贝 两者指向的空间不一样的，但值是一样的
    }
    ~Person() 
    {
    	if (b != NULL)
        {
            delete b;
            b = NULL;
        }
    }
}
```



## 2.构造函数

主要用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。

不写时编译器会自动提供一个空实现的构造函数

**语法：**`类名(){}`

- 无返回值，不写void
- 函数名与类名相同
- 构造函数可以有参数、可以发生重载
- 创建对象时，构造函数自动调用，且只调用一次

```c++
class Person
{
public:
    Person()
    {
    	cout << "我是构造函数" << endl;
    }
}
```

**分类：**

- 有参构造和无参(默认)构造

- 普通构造和拷贝构造

  ```c++
  class Person
  {
  public:
      // 普通构造
      Person()
      {
      	cout << "我是构造函数" << endl;
      }
      
      // 拷贝构造，浅拷贝
      Person(const Person& p)
      {
      	cout << "我是构造函数" << endl;
      }
  }
  ```

**调用方式：**

- 括号法
- 显示法
- 隐式转换法

```c++
// 括号法
Person p1; // 默认构造（注意事项：调用默认构造时不要加括号，因为编译器会认为这是一个函数的声明）
Person p2(10); // 有参构造
Person p3(p2); // 拷贝构造

// 显示法
Person(10); // 匿名对象，特点：当前行执行结束后，系统会立即回收匿名对象
Person p1 = Person(10); // 显示调用有参构造
Person p2 = Person(p1); // 显示调用拷贝构造
Person(p1); // 注意事项：不同用拷贝构造，初始化匿名对象，编译器会认为这是一个对象声明Person(p1) = Person p1

// 隐式转换法
Person p1 = 10; // 相对于Person p1 = Person(10); 调用了有参构造
Person p2 = p1; // 相对于Person p2 = Person(p1); 调用了拷贝构造

```

### 2.1 拷贝构造函数调用时机

- 使用一个已经创建完毕的对象来初始化一个新对象

  ```c++
  Person p1(10);
  Person p2(p1);
  ```

- 值传递的方式给函数参数传值

  ```c++
  void Test(Person P)  // 此处调用了Person的拷贝构造，构造了一个新的对象作为形参
  {
      
  }
  Person p1;
  Test(p1);
  ```

- 值方式返回局部对象

  ```c++
  Person Test()
  {
      Person p1;
      return p1; // 此处调用了Person的拷贝构造，返回了一个新的对象出去
  }
  
  Person p2 = Test(); // p2与p1不等，p1在Test方法执行完毕后就销毁了
  ```

### 2.2构造函数调用规则

默认情况下，C++编译器会给一个类添加3个函数

- 默认构造函数（无参，空实现）

- 默认析构函数（无参，空实现）

- 默认拷贝函数，对属性进行值拷贝

  **规则：**

  - 若自定义了有参构造函数，则编译器不再提供默认无参构造，但会提供默认拷贝构造
  - 若自定义了拷贝构造函数，则编译器不再提供其他构造函数



## 3.析构函数

主要用于对象销毁前系统自动调用，执行一些清理工作

不写时编译器会自动提供一个空实现的析构函数

**语法：**`~类名(){}`

- 无返回值，不写void
- 函数名与类名相同，名称前要加~
- 构造函数不能有参数、不可以发生重载
- 创建对象时，构造函数自动调用，且只调用一次

```c++
class Person
{
public:
    ~Person()
    {
    	cout << "我是析构函数" << endl;
    }
}
```



## 4.初始化列表

**作用：**用于初始化属性

**语法：**`构造函数():属性1(值1),属性2(值2)...{}`

```c++
class Person
{
public:
    int a;
    int b;
    
    // 初始化列表：10赋值给a，20赋值给b
    Person():a(10),b(20)
    {
        
    }
    
    // 初始化列表: a1赋值给a，b1赋值给b（更灵活）
    Person(int a1, int b1):a(a1),b(b1)
    {
        
    }
}
Person(10, 20);
```



## 5.类对象作为类成员

```c++
class A{}
class B
{
    // 当类中有其他类对象时，先构造其他类对象，再构造自身
    // 析构时，先释放自身，再释放自身中包含的其他类对象
    A a; 
}
```



## 6.静态成员

- **静态成员变量**

  1. 所有对象共享一份数据
  2. 在编译阶段分配内存
  3. 类内声明，类外初始化

  ```c++
  class Person
  {
  public:
      // 静态成员变量
      static int a; // 类内声明
  }
  int Person::a = 10; // 类外初始化
  int main()
  {
      Person p;
      // 1.通过对象进行访问
      cout << p.a << endl;
      
      // 2.通过类名进行访问
      count << Person::a <<endl;
      return 0;
  }
  ```

  

- **静态成员函数**

  1. 所有对象共享一个函数
  2. 静态成员函数只能访问静态成员变量

  ```c++
  class Person
  {
  public:
      // 静态成员函数
      static void Test();
  }
  
  int main()
  {
      Person p;
      // 1.通过对象进行访问
      p.Test();
      
      // 2.通过类名进行访问
      Person::Test();
      return 0;
  }
  ```

  

