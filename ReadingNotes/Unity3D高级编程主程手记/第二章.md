# 第二章 C#技术要点

## 2.1 Unity3D中C#的底层原理
本节介绍的是Unity运行C#程序的两种机制，以及其它们的区别和原理
  - **Mono：** 是一个跨平台.Net框架的实现。Unity中通过将C#代码编译成IL代码，然后运行在Mono虚拟机上，再由虚拟机转译成机器码执行。IL三种转译模式
    - Just-in-time(JIT)：即时编译，在程序运行过程中将IL代码转译成机器码执行。
    - Ahead-of-time(AOT)：预编译，将IL代码转译成机器码并存储在文件中，但此文件不能完全独立运行，该模式可以产生绝大部分JIT模式所产生的机器码，但还是有部分代码需要JIT模式运行。
    - 完全静态编译：此模式只支持少数平台，基于AOT模式更进一步产生所有的机器码，让程序运行时完全不需要JIT，适用于ios、xbox360等不支持JIT的操作系统。

  - **IL2CPP：** 将IL代码转译成C++代码。Unity通过Mono将C#编译成IL代码，再有IL2CPP转译成C++代码，最后由各平台的C++编译器编译成机器码执行。IL2CPP也有虚拟机不用于执行代码，而是做内存管理。

## 2.2 List源码剖析

## 2.3 Dictionary源码剖析

## 2.4 浮点数的精度问题
  - **存储方式：** 以二进制的科学计数法形式存储，公式：f = -1^s * M * 2^E
    - s：符号位，0表示正数，1表示负数
    - M：尾数，转为科学计数法表示后去掉1后的小数部分，如1.001101->001101
    - E：指数，科学计数法的指数部分，如1.001101*2^3->3

  - **计算方式：** 浮点数十进制转二进制，整数部分采用除2取余法，小数部分采用乘2取整法。如9.625->1001.101->1.001101*2^3

  - **精度问题**
    - **尾数能表达的位数有限**
      - 二进制无法精确表示一些十进制的小数，如0.1，0.2等，因为小数的最后一位不是5的小数在二进制中都是无限循环的，因此在计算机中只能取近似值。
      - 即使浮点数全是整数，当整数超出浮点数的范围时也会出现无法准确表达的问题
    - **数值比较不相等：** 由于二进制无法精确表示一些十进制数，如一个数在0.23时干一件事，在0.34时干一件事，虽然从数学角度上说可以判断相等，但从计算机层面看，由于表示的误差存在无法精准比较想等，只能大于、小于区间比较，或者需要一个小的浮动区间来比较相等，如使用Math.Abs(a-b)<0.00001这样的方式。
    - **数值计算的不确定：** 如x = 1f,y= 2f, z = 1f / 5555f x 11110f, x/y与z比较从数学角度上一定是相等的但从计算机层面上看，x/y是精准的0.5f，而z由于无法精确表示可能是0.4999999f或0.5000001f，因此x/y与z比较大于或小于时开发人员在编写时无法正确判断的。
    - **不同设备的计算结果不同：** 由于CPU寄存器和操作系统的架构不同，会导致相同公式在不同设备上计算结果会有偏差
  
  - **解决方法**
    - **简单方法：** 用一台设备计算结果，只计算一次，其余设备都用这个结果。
    - **int或long来代替浮点数：** 浮点数与整数计算方式都一致，只是小数部分不同。因此可以根据需要的精度将浮点数乘10的幂次来转换为整数计算和存储，需在考虑精度满足要求后，浮点数放大为整数后数值计算的范围可能溢出问题
    - **定点数：** 浮点数使用f=-1^s * M * 2^E公式表示，其表达是模糊的。而定点数则把整数和小数部分分开都用整数表示，由于整数的计算和表示都是确定的，所以不会存在误差。其缺点是整数和小数都要占用空间存储，由于存储位数的限制，字节占用多了就会使计算范围相对缩小。
      - **C# decimal：** 实现方式可看成定点数，但仍是浮点数，只是按十进制计算的，占16个字节128位存储空间，精度范围有28个有效位，有更高的精度却比float表示的范围小。但不作为游戏开发的首选，而适用于财务或金融软件。因为无法与普通浮点数任意转换，且精度过大导致cpu计算消耗大，存储空间占用高等问题不适用于游戏。
      - **自己实现的定点数：** 用两个int来分别存储整数和小数部分。推荐用long来实现，前32位存整数，后32位存小数部分，都用整数表示便于计算和存储，实现加减乘除、大于小于等比较运算符重载，编写额外的数学库，如坐标向量类、Quaternion等。
      - **字符串代替浮点数：** 当精确度要求非常高，定点数和浮点数无法满足要求时。将中小学的笔算方式写入程序，字符串的每一个字符表示一个数字，取出来做整数运算后再存入字符串，这样不用考虑范围且可控精度，但性能最差很消耗内存和cpu，只适用于精度要求很高且计算次数较少的场景。

## 2.5 委托、事件、装箱、拆箱
  - **委托：** 关键字delegate，System.MulticastDelegate的子类，内部使用链表存储函数指针。
  - **事件：** 关键字event，对委托的进一步封装，限制了赋值权限，外界只能+=、-=赋值，不能直接=赋值，防止外界直接清空委托链表
  - **装箱：** 值类型实例转换为引用类型实例
  - **拆箱：** 引用类型实例转换为值类型实例
  - **栈内存：** 一块连续的内存，先进后出，栈上内存创建和删除的时间复杂度为O(1)，栈上存储的数据的生命周期必须确定。
  - **堆内存：** 随机分配的空间，数据定位至少需要两次，堆上内存创建和删除的时间复杂度为O(logn)，堆上可以存放一些生命周期不确定的数据。
  - **值类型与引用类型误区：** 值类型与引用类型不能以栈内存和堆内存来区分，因为值类型也可以存储在堆上，引用类型也可以存储在栈上，堆内存与栈内存主要体现数据不同生命周期的两种内存服务。
  - **struct优化：** 结构体是值类型又可继承接口，易出现装箱，以下是避免装箱的方法
    - **重载函数：** 对ToString()，GetType()等方法，若struct未重载这些方法，再调用时就会装箱。
    - **泛型：** 当struct继承一个接口时，可通过泛型，将接口做泛型约束，用泛型来传递strcut，可避免直接使用接口来表示struct时引起的装箱。如Test(I i) 结构体A继承I,当传入A时会装箱，可将Test(I i)改为Test<T>(T t) where T : I 来避免装箱。
    - **通过继承统一接口提前装箱与拆箱来避免多次重复的拆装箱：** 

## 2.6 排序算法
一个项目中90%用到的最多的算法就是排序和搜索算法
  - **快速排序：** 时间复杂度O(nlogn)，最差O(n^2)，不消耗额外存储空间。
    - **步骤：** 选一个基准数，将比基准数小的放其左边，大的放其右边，再对左右两边区间的数递归调用此方法，直至无法再细分区间则排序完毕。
    - **最差情况：** 每次选取的基准数都是最大最小的，或偏大偏小的，筛选时都相对需要充分移动。
    - **优化：** 优化基准数的选择
      - **随机选择基准数：** 每次随机选取基准数，避免每次都选最大或最小的数，但随机也有不确定性。
      - **三数取中法：** 每次选取数组的头、中、尾三个数，排序后取中间值作为基准数，可适当扩展至四，五位数取中值，但每次数取多了会增加计算量，相当于多了一个排序算法了。
      - **小区间使用插入排序：** 插入排序在小序列（8个元素），序列越有序的情况下，效率很高。因此当区间元素小于8时，使用插入排序代替快速排序，通过混合的形式使快速排序的效率更高。
      - **缩小分割范围，将与基准数相同的数合并在一起：** 每次分割区间时，将与基准数相同的数放在一起，分割区间时，区间边界的选取就从与基准数相同数的最边上的数开始。
  - **最大堆与最小堆：** 由完全二叉树的结构支撑，普通堆排序算法比快速排序效率低，但最大堆与最小堆在只关注最大值和最小值的情况下最有用，每次修改、增加、删除元素后获取最大值和最小值时效率较高，因此常用于A星算法。
    - **代码实现：** 使用数组表示完全二叉树结构，每个节点及其两个子节点，节点与数组索引规则，i为节点索引2i和2i+1则为左右子节点索引，i/2为父节点索引。
    - **优先级队列：** 在插入新元素时删除最小或最大的元素。
  - **桶排序：** 即将所有元素按一定大小分成N个组，每个组内再分别进行快速排序，得到N个有序的数组并得到N个桶的记录，该记录对模糊排序或模糊搜索的时候很有用。
  - **基数排序：** 针对元素的特性进行分配式排序，如数字的个位、十位、百位等，每次按位将数分配后0到9个桶中，再几次合并就得到有序的数组。

## 2.7 各类搜索算法
广度优先和深度优先的搜索算法是最常见的，但不加修饰的广度或深度优先搜索算法的整体效率较差。
  - **二分查找算法：** 时间复杂度O(logn)，只适用于有序数组。
    - **步骤：** 将数组分为左右两个区间，取中间值与目标值比较，若相等则返回，若小于目标值则在右区间继续查找，若大于目标值则在左区间继续查找，直至找到目标值或区间无法再细分。
  - **二叉树、二叉查找树、平衡二叉树、红黑树、B树：** 二叉树的所有衍生算法都是基于一个父节点有至多两个子节点的规则。
    - **二叉查找树：** 构造时左子节点一定比父节点小，右子节点一定比父节点大，查找算法与二分查找类似，但由于原始数据的排列不同，该树可能形成一个深度很大的二叉树犹如直线连接的节点，由于依赖原始数据的排列方式，所以其稳定性不高。
    - **二叉平衡树：** 解决了二叉树与二叉查找树不平衡的问题，规则要求父节点下的左右子节点的树深度差不超过1，对所有节点都要求这个规则，因此解决了深度问题。
      - **红黑树：** 一种实现二叉平衡树的算法，其特点是各节点多了一个颜色值，分为红色和黑色。通过从根节点到叶子节点的路径上对各节点着色，确保没有一条路径比其他路径长两倍，因此红黑树是近似平衡的。
      - **B树：** 为磁盘存储而设计的一种二叉平衡树，是建立在查找树上的多叉树，它的一个节点上有多个值且父节点可以有用两个以上的子节点，同时保持树的深度不超过logn（n为节点个数），其比较方式由单一值变成多值比较，B树中一个节点的信息是一个数组且有序的，因此可以通过二分查找来查找数据，若找不到则继续往下搜索子节点的信息。
        - **B+树、B*树：** B树的衍生算法。
  - **四叉树搜索算法：** 类似二叉树的多维版本，理念是空间划分，将一个二位空间划分成多个部分来存放。数据结构与二叉树类似，只是每个父节点的子节点个数扩展至四个，四个子节点代表四个象限区域，四个子节点加起来代表一个完整的父节点。
    - **应用：** 二维平面上的有效碰撞检测搜索范围、地形的有效展示范围、地图上查找某方块上的事物及二维平面的寻路网格构建等。
  - **八叉树搜索算法：** 与四叉树类似，更关注3D空间上的划分。将一个立方体分割成八个小立方体，每个父节点的子节点个数扩展至八个，八个子节点代表八个立方体区域，八个子节点加起来代表一个完整的父节点。。
    - **应用：** 渲染中的渲染裁切、物理引擎的碰撞检测等。

## 2.8 业务逻辑优化技巧
  - **使用List和Dictionary时提高效率**
    - **List：** 内部用数组存储，因此注意其Insert、Remove、Contains等接口都是遍历数组，要考虑其带来的性能损耗。
    - **Dictionary：** Hash冲突率与内部数组大小有关，因此初始化字典时应该设置一个合理的大小。Object类GetHashCode方法，是将内存地址转为HashCode，可认为是一个算法未对任何值缓存，每次调用会是一个隐形的性能消耗，因此当Object作为字典的key时，可以考虑唯一ID来替代调用GetHashCode方法。
    - **巧用strcut：** strcut是值类型，当作为局部变量时其存储在栈上，无需GC，不会产生内存碎片。值类型内存是连续的，对缓存命中率友好，但当结构体大小超过了缓存的大小时，则不起作用。于是，`有种方案彻底使用原值类型的数组（int[]、bool[]、float[]等）来提高cpu缓存命中率，将数值用数组统一存储起来，具体对象上存一个索引，通过索引来操作数组`，代码示例如下。
        ```csharp
        class A 
        { 
            int ageIndex;  
            int heightIndex;
            int isBoyIndex;
        }
        class B 
        {
            int[] a = new int { 1, 2, 3};
            float[] b = new int { 1.1f, 2.1f, 3.1f};
            bool[] c = new int { true, false, false};
        }
        var b = new B();
        var a = new A();
        var age = b[a.ageIndex];
        var height = b[a.heightIndex];
        var isBoy = b[a.isBoyIndex];
        ```
  - **尽可能地使用对象池**
    - 通过ListPool、DictionaryPool、ObjectPool等来创建对象池，避免频繁的new和GC。
    - 提前预加载对象池，在程序运行的某个时刻，提前分配一些对象在对象池中，避免在关键时刻因分配对象导致的性能损耗
  
  - **字符串导致的性能问题：** 字符串的性能问题在大部分语言中都是比较难解决的。每次动态创建一个string，或者拼接、分割等操作一个string时都会新分配一份或多份内存空间。
    - **常量字符串：** 代码中写的字面量字符串会被编译器优化都会被放入一个常量字符串缓存池中，后面使用时会直接从缓存池中获取，不会分配额外空间。
    - **解决字符串问题的方法**
      - **自建缓存机制：** 将一些常用字符串通过标志性的key存储在字典中，使用时通过key来获取，没有时则构造好后添加到字典中
      - **使用指针来处理字符串：** 建立一个字典缓存不同长度的字符串，当进行字符串的拼接、分割等操作时，使用指针的方式修改字典中缓存的对应长度的字符串内容并返回，

  - **字符串的隐藏问题**
    - 在调用ToCharArray()时，返回的是一个新创建的字符串数组与原string无关。
    - 在调用sting.Clone()、String.ToString()时，返回的是原字符串。
    - 字符串比较相等时，会先比较其引用是否相同，相同则直接返回true，不同则会比较字符串每个字符是否相同

  - **程序运行原理**
    - **业务逻辑优化围绕的点：** 如何利用好CPU的缓存命中率、如何减少内存分配和卸载次数、如何利用好多线程并让其协作顺畅。
    - **程序的运行时的几个内存块**
      - **指令内存块：** 程序中写的方法都会编译成指令存在于此
      - **数据内存块：** 程序运行时的所有数据都会存在于此
        - **静态数据内存块：** 存储一些不变得数据，如：字符串常量、常量整数或浮点数等，这些数据在程序启动时最先放入内存中。
        - **堆内存块：** 存储一些动态创建的数据，如：new出来的对象、数组等，这些数据在程序运行时动态创建。
      - **栈内存块：** 函数方法执行时的重要部分
      - **寄存器：** 离CPU最近的存储单元，用来存放一些临时数据，也可自己写汇编让寄存器长期存储一些数据，加快读取某数据的速度。

## 个人总结
这本书的第二章篇幅比较长、内容比较多且碎，其主旨是在讲C#的一些知识要点。先从unity中C#运行的底层原理开始，再从源码角度剖析C#的常用数据结构，再到常用的排序算法和搜索算法，最后到具体的业务逻辑优化技巧，中途穿插讲解浮点数的精度问题和委托与事件、装箱与拆箱。整体下来感觉收获很多但也感到一些不足，有的内容比较浅显不够深入（可能碍于篇幅无法大量讲解），`其中说算法这种基础能力是程序员生涯最重要的，比熟悉各种API了解各种工具更加重要，对此我非常赞同`。  
个人觉得游戏程序员有三大能力吧，逻辑能力、设计能力（更深一步可能是架构能力）、数学或算法能力，最开始入行可能逻辑能力成长比较快，逐步的在应对各种复杂业务时需要足够的设计能力，最后在解决一些底层核心问题时需要足够的数学或算法能力，当然最重要的还是学习能力。  
最后回到书中第二章，我觉得其中说的快排算法的优化（基准数三数取中法、相同基准数合并、小数组用插入排序）、字符串的优化（通过指针修改字符串内容重复利用）这两内容给我得印象比较深，个人觉得非常实用。
