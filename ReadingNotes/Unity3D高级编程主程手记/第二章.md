## 2.1 Unity3D中C#的底层原理
本节介绍的是Unity运行C#程序的两种机制，以及其它们的区别和原理
  - **Mono：** 是一个跨平台.Net框架的实现。Unity中通过将C#代码编译成IL代码，然后运行在Mono虚拟机上，再由虚拟机转译成机器码执行。IL三种转译模式
    - Just-in-time(JIT)：即时编译，在程序运行过程中将IL代码转译成机器码执行。
    - Ahead-of-time(AOT)：预编译，将IL代码转译成机器码并存储在文件中，但此文件不能完全独立运行，该模式可以产生绝大部分JIT模式所产生的机器码，但还是有部分代码需要JIT模式运行。
    - 完全静态编译：此模式只支持少数平台，基于AOT模式更进一步产生所有的机器码，让程序运行时完全不需要JIT，适用于ios、xbox360等不支持JIT的操作系统。

  - **IL2CPP：** 将IL代码转译成C++代码。Unity通过Mono将C#编译成IL代码，再有IL2CPP转译成C++代码，最后由各平台的C++编译器编译成机器码执行。IL2CPP也有虚拟机不用于执行代码，而是做内存管理。

## 2.2 List源码剖析

## 2.3 Dictionary源码剖析

## 2.4 浮点数的精度问题
  - **存储方式：** 以二进制的科学计数法形式存储，公式：f = -1^s * M * 2^E
    - s：符号位，0表示正数，1表示负数
    - M：尾数，转为科学计数法表示后去掉1后的小数部分，如1.001101->001101
    - E：指数，科学计数法的指数部分，如1.001101*2^3->3

  - **计算方式：** 浮点数十进制转二进制，整数部分采用除2取余法，小数部分采用乘2取整法。如9.625->1001.101->1.001101*2^3

  - **精度问题**
    - **尾数能表达的位数有限**
      - 二进制无法精确表示一些十进制的小数，如0.1，0.2等，因为小数的最后一位不是5的小数在二进制中都是无限循环的，因此在计算机中只能取近似值。
      - 即使浮点数全是整数，当整数超出浮点数的范围时也会出现无法准确表达的问题
    - **数值比较不相等：** 由于二进制无法精确表示一些十进制数，如一个数在0.23时干一件事，在0.34时干一件事，虽然从数学角度上说可以判断相等，但从计算机层面看，由于表示的误差存在无法精准比较想等，只能大于、小于区间比较，或者需要一个小的浮动区间来比较相等，如使用Math.Abs(a-b)<0.00001这样的方式。
    - **数值计算的不确定：** 如x=1f,y=2f, z=1f/5555fx11110f, x/y与z比较从数学角度上一定是相等的但从计算机层面上看，x/y是精准的0.5f，而z由于无法精确表示可能是0.4999999f或0.5000001f，因此x/y与z比较大于或小于时开发人员在编写时无法正确判断的。
    - **不同设备的计算结果不同：** 由于CPU寄存器和操作系统的架构不同，会导致相同公式在不同设备上计算结果会有偏差
  
  - **解决方法**
    - **简单方法：** 用一台设备计算结果，只计算一次，其余设备都用这个结果。
    - **int或long来代替浮点数：** 浮点数与整数计算方式都一致，只是小数部分不同。因此可以根据需要的精度将浮点数乘10的幂次来转换为整数计算和存储，需在考虑精度满足要求后，浮点数放大为整数后数值计算的范围可能溢出问题
    - **定点数：** 浮点数使用f=-1^s * M * 2^E公式表示，其表达是模糊的。而定点数则把整数和小数部分分开都用整数表示，由于整数的计算和表示都是确定的，所以不会存在误差。其缺点是整数和小数都要占用空间存储，由于存储位数的限制，字节占用多了就会使计算范围相对缩小。
      - **C# decimal：** 实现方式可看成定点数，但仍是浮点数，只是按十进制计算的，占16个字节128位存储空间，精度范围有28个有效位，有更高的精度却比float表示的范围小。但不作为游戏开发的首选，而适用于财务或金融软件。因为无法与普通浮点数任意转换，且精度过大导致cpu计算消耗大，存储空间占用高等问题不适用于游戏。
      - **自己实现的定点数：** 用两个int来分别存储整数和小数部分。推荐用long来实现，前32位存整数，后32位存小数部分，都用整数表示便于计算和存储，实现加减乘除、大于小于等比较运算符重载，编写额外的数学库，如坐标向量类、Quaternion等。
      - **字符串代替浮点数：** 当精确度要求非常高，定点数和浮点数无法满足要求时。将中小学的笔算方式写入程序，字符串的每一个字符表示一个数字，取出来做整数运算后再存入字符串，这样不用考虑范围且可控精度，但性能最差很消耗内存和cpu，只适用于精度要求很高且计算次数较少的场景。

## 2.5 委托、事件、装箱、拆箱
  - **委托：** 关键字delegate，System.MulticastDelegate的子类，内部使用链表存储函数指针。
  - **事件：** 关键字event，对委托的进一步封装，限制了赋值权限，外界只能+=、-=赋值，不能直接=赋值，防止外界直接清空委托链表
  - **装箱：** 值类型实例转换为引用类型实例
  - **拆箱：** 引用类型实例转换为值类型实例
  - **栈内存：** 一块连续的内存，先进后出，栈上内存创建和删除的时间复杂度为O(1)，栈上存储的数据的生命周期必须确定。
  - **堆内存：** 随机分配的空间，数据定位至少需要两次，堆上内存创建和删除的时间复杂度为O(logn)，堆上可以存放一些生命周期不确定的数据。
  - **值类型与引用类型误区：** 值类型与引用类型不能以栈内存和堆内存来区分，因为值类型也可以存储在堆上，引用类型也可以存储在栈上，堆内存与栈内存主要体现数据不同生命周期的两种内存服务。
  - struct优化：结构体是值类型又可继承接口，易出现装箱，以下是避免装箱的方法
    - **重载函数：** 对ToString()，GetType()等方法，若struct未重载这些方法，再调用时就会装箱。
    - **泛型：** 当struct继承一个接口时，可通过泛型，将接口做泛型约束，用泛型来传递strcut，可避免直接使用接口来表示struct时引起的装箱。如Test(I i) 结构体A继承I,当传入A时会装箱，可将Test(I i)改为Test<T>(T t) where T : I 来避免装箱。
    - **通过继承统一接口提前装箱与拆箱来避免多次重复的拆装箱：** 

## 2.6 排序算法
一个项目中90%用到的最多的算法就是排序和搜索算法
  - **快速排序：** 时间复杂度O(nlogn)，最差O(n^2)，不消耗额外存储空间。
    - **步骤：** 选一个基准数，将比基准数小的放其左边，大的放其右边，再对左右两边区间的数递归调用此方法，直至无法再细分区间则排序完毕。
    - **最差情况：** 每次选取的基准数都是最大最小的，或偏大偏小的，筛选时都相对需要充分移动。
    - **优化：** 优化基准数的选择
      - **随机选择基准数：** 每次随机选取基准数，避免每次都选最大或最小的数，但随机也有不确定性。
      - **三数取中法：** 每次选取数组的头、中、尾三个数，排序后取中间值作为基准数，可适当扩展至四，五位数取中值，但每次数取多了会增加计算量，相当于多了一个排序算法了。
      - **小区间使用插入排序：** 插入排序在小序列（8个元素），序列越有序的情况下，效率很高。因此当区间元素小于8时，使用插入排序代替快速排序，通过混合的形式使快速排序的效率更高。
      - **缩小分割范围，将与基准数相同的数合并在一起：** 每次分割区间时，将与基准数相同的数放在一起，分割区间时，区间边界的选取就从与基准数相同数的最边上的数开始。
  - **最大堆与最小堆：** 由完全二叉树的结构支撑，普通堆排序算法比快速排序效率低，但最大堆与最小堆在只关注最大值和最小值的情况下最有用，每次修改、增加、删除元素后获取最大值和最小值时效率，因此常用于A星算法。