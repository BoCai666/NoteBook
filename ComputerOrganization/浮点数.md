## 浮点数
- **表示方式：** `(-1)^s * M * 2^E`，其中s为符号位，M为尾数，E为指数。浮点数为了表示更大和更小的数采用科学计数法在计算机中存储。
- **单精度：** 占32位（1位符号位，8位指数位，23位尾数位）尾数为23位，所以float小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位，计算2^(23+1) = 16777216，因为 10^7 < 16777216 < 10^8，所以说单精度浮点数的有效位数是7位；
  ```
    0 | 11111110 |11111111111111111111111 // 0x7f7fffff
    s-|-----e----|------------m----------  
    符号位s为0 （正数）
    e = 11111110 即十进制的254，所以 E = e - bias = 254 - 127 =127 (注意：当e全为1即e=255时，这时表示的是无穷（inf）或者不是一个数字)
    m = 1111....1111 (23个1）, 所以 M = 1 * m = 1.11111...1111
    
    最后计算最大值，二进制的表达式为：
    ProMax(B) = (-1)^s * M * 2^E = +(1.11111.....11111) * 2^127 约等 3.402e38
    
    十进制的表达式为：
    ProMax(D) = 2^128 - 1 约等 3.402e38
  ```
  
- **双精度：** 占64位（1位符号位，11位指数位，52位尾数位）尾数部分52位，所以精确到小数点后15位，有效位数为16位，计算2^(52+1) = 9007199254740992，10^16 < 9007199254740992 < 10^17，所以双精度的有效位数是16位；

### 示例：
- 8.25 十进制：8.25 * 10^0，二进制：1000.01->1.00001 * 2^3
- 120.5 十进制：1.205 * 10^2，二进制：111 1000.1->1.11 1000 * 2^6
- 总结：所有数的尾数部分都可表示为1.xxx，故计算机将小数点前面的1省略，所以23bit的尾数部分，可以表示的精度却变成了24bit，那24bit能精确到小数点后几位呢，我们知道9的二进制表示为1001，所以4bit能精确十进制中的1位小数点，24bit就能使float能精确到小数点后6位，而对于指数部分，因为指数可正可负，8位的指数位能表示的指数范围就应该为:-127-128了，所以指数部分的存储采用移位存储，存储的数据为元数据+127。

### 误差:
- **举例分析：** 单精度的2.2转换为双精度后，精确到小数点后13位后变为了2.2000000476837，而单精度的2.25转换为双精度后，变为了2.2500000000000，因为2.2将十进制的小数转换为二进制的小数的方法为将小数2，取整数部分，所以0.2x2=0.4，所以二进制小数第一位为0.4的整数部分0，0.4×2=0.8，第二位为0,0.82=1.6,第三位为1，0.6×2 = 1.2，第四位为1，0.22=0.4，第五位为0，这样永远也不可能乘到=1.0，得到的二进制是一个无限循环的排列00110011001100110011...,对于单精度数据来说，尾数只能表示24bit的精度，所以2.2的float存储会舍弃一些位数，但是这样存储方式，换算成十进制的值，却不会是2.2的，而double类型的数据也存在同样的问题，所以在浮点数表示中会产生些许的误差，在单精度转换为双精度的时候，也会存在误差的问题，对于能够用二进制表示的十进制数据，而如2.25，这个误差就会不存在，所以会出现上面比较奇怪的输出结果。

## 定点数
即约定计算机中小数点的位置，且这个位置固定不变，小数点前、后的数字，分别用二进制表示，然后组合起来就可以把这个数字在计算机中存储起来，这种表示方式叫做「定点」表示法，用这种方法表示的数字叫做定点数