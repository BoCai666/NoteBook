## [简介](https://juejin.cn/post/6963931777962344455)
`HyperText Transfer Protocol`全名超文本传输协议，是一个应用层无状态性的协议，由请求和响应构成，是一个标准的客户端服务器模型。永远是客户端请求，服务器响应，服务器不会主动推送。

## 概念
- **url：** 是由：协议、域名/ip地址、端口三部分组成。
如：https://blog.moonlet.cn:80

- **跨域：** 当一个请求url的协议、域名、端口三者之间的任意一个与当前页面url不同即为跨域

- **同源策略：** 同源策略（Same Orgin Policy）是一种约定，它是浏览器核心也最基本的安全功能，它会阻止一个域的js脚本和另外一个域的内容进行交互，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源（即在同一个域）就是两个页面具有相同的协议（protocol）、主机（host）和端口号（port）。无法读取非同源网页的cookie、localstorage等，无法接触非同源网页的DOM和js对象，无法向非同源地址发送Ajax请求。

- **无状态性：** 是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。

- **无连接：** 每次请求都需要建立tcp连接
  
- **cookie：** 用于告知服务端前后两个请求是否来自同一浏览器，cookie存储在客户端，它是由服务器发送到浏览器并保存在本地的数据，会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。cookie是不可跨域的，每个cookie都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是domain）。
  
- **session：** 另一种记录服务器和客户端会话状态的机制，是基于cookie实现的，session存储在服务器端，sessionId会被存储到客户端的cookie中，用户第一次请求服务器的时候，服务器根据用户提交的相关信息创建对应的Session，在请求返回时将此Session的唯一标识信息SessionID返回给浏览器，浏览器接收到服务器返回的SessionID信息后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名，当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在Cookie信息，如果存在自动将Cookie信息也发送给服务端，服务端会从Cookie中获取 SessionID，再根据SessionID查找对应的Session信息，如果没有找到说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。根据以上流程可知，SessionID是连接Cookie和Session的一道桥梁，大部分系统也是根据此原理来验证用户登录状态
  - 安全性：Session比Cookie安全，Session是存储在服务器端的，Cookie是存储在客户端的。
  - 存取值的类型不同：Cookie只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session可以存任意数据类型。
  - 有效期不同：Cookie可设置为长时间保持，Session一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时（一般30分钟无操作）都会失效。
  - 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie，但是当访问量过多，会占用过多的服务器资源

- **Keep-Alive：** 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个TCP连接；所谓长连接，即在请求结束，TCP连接不断开，继续保持一段时间（timeout），在这段时间内，同一客户端向服务器发送请求都会复用该TCP连接，并重置timeout时间计数器，在接下来timeout时间内还可以继续复用TCP。

- **浏览器缓存：** 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识，每次从服务器端拿到返回的请求结果，都会将该结果和缓存标识存入浏览器缓存。
  - 本地缓存（强缓存）：向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程 Expires（HTTP/1.0）Cache-Control（HTTP/1.1）
  - 协商缓存（再验证）：强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程 Last-Modified 和 If-Modified-Since（HTTP/1.0）ETag 和 If-None-Match（HTTP/1.1）


## 版本
- **1.0：** 无状态、无连接，通过`cookie/session`来做身份认证和状态记录
  - 无法复用连接。每次发送请求的时候，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会导致网络的利用率非常低。
  - 队头堵塞(head of line blocking)。由于HTTP/1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设一个请求响应一直不到达，那么下一个请求就不发送，就到导致阻塞后面的请求
- **1.1：** 长连接，支持请求管道化（pipelining）
  - 长连接：增加了一个Connection字段，通过设置Keep-alive（默认已设置）可以保持连接不断开，如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求
  - 请求管道化：长连接使得请求管线化成为可能。管线化使得请求能够“并行”传输，服务器必须按照客户端请求的先后顺序依次回送相应的结果，但这个是很大的一个缺陷。现阶段的浏览器厂商采取了另外一种做法，允许打开多个TCP的会话，其并行是在不同的TCP连接上的HTTP请求和响应。这也就是浏览器对同域下并行加载6~8个资源的限制。而这，才是真正的并行！此外，还加入了缓存处理，新的字段如cache-control，支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）
- **2.0：** 采用二进制格式传输，非1.x的文本格式，二进制解析更加高效，将请求和响应数据分割为更小的帧。
  - 帧：HTTP/2中的最小数据单位，每个帧都包含帧头，帧头至少包含帧的长度、类型和标识符，请求或响应消息由一个或多个帧组成。
  - 流：存在连接中的一个虚拟通道，流可以承载双向消息，每个流都有一个唯一的整数ID
  - 消息：与逻辑消息对应的完整的一系列数据帧
  - 多路复用：同域名下的所有通信都在单个连接中完成。单个连接可以承载任意数量的双向数据流。 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。这一特性，使性能有了很大的提升：同个域名只需要占用一个TCP连接，消除了因多个TCP连接而带来的延时和内存消耗。单个连接上可以并行交错地请求和响应，之间互不干扰。每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。
  2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。
  - 服务器推送：服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。
  - 头部压缩：在1.x中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷。比如说cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发送给服务器。（由于cookie比较大且每次都重复发送，一般不存储信息，只是用来做状态记录和身份认证）。2.0中使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。

## 标识符
- **http：** 未加密 例：http://example.com:80/some/path
- **https：** 已加密 例：http://example.com:80/some/path

## 请求（Request）
- **动作**
  - get：向服务器拉取数据
  - post：向服务器传输数据
  - options ：获取服务器支持的HTTP请求方法
  - head：获取资源的元数据
  - put：向服务器传输文件
  - delete：删除服务器上的文件
  - trace：追踪请求-响应的传输路径
  - connect：建立特殊的连接隧道
  - patch：对资源进行部分修改
- **参数：** 参数用&符隔开
  - url：get请求的参数放在url中，如 `http://www.baidu.com?name=jack&age=18` 格式为：地址?参数名=参数值&参数名=参数值
  - request body：post请求的参数放在请求体中

## 响应（Response）
- **status：** 状态码
  - 200：请求成功
  - 301：永久重定向
  - 302：临时重定向
  - 404：请求资源不存在
  - 500：服务器内部错误
  - 503：服务器暂时不可用
- **headers：** 响应头
- **body：** 响应体